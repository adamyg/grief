/* $Id: language.cr,v 1.25 2014/11/24 11:10:51 ayoung Exp $
 * File type/extension language support macros.
 *
 *  You can attach these packages so that they are automaticlly used with
 *  program files that have special file extensions. The BPACKAGES
 *  environment variable is used by all file extension dependent
 *  packages, including simple text formatting (word processing) and
 *  independently marketed packages.
 *
 *  The format of 'package' is:
 *
 *      package: extension[,extension]...[-equivalent]:\
 *            package [args],package...;extension...
 *
 *  extension
 *      is the file extension that will invoke a specific style. One or more
 *      comma seperarted extension can be specified for each style.
 *
 *      Note: the special extension "default" is used to specify all
 *      extensions not specifically included in the BPACKAGES string.
 *
 *  equivalent
 *      the optional value specifies that the preceding extensions should
 *      be treated the same as the "equivalent extension" by the language
 *      sensitive features, an extension override.
 *
 *      All extensions preceding the equivalent extension back to preceding
 *      semicolon, another equivalent extension, or the beginning of the
 *      BPACKAGES definition are affected by the command. Hence given:
 *
 *          package: .asm:.r;.cpp.hpp.h-c:smart
 *
 *      GRIEF would consider extensions '.cpp', '.hpp' and '.h' equivlent to
 *      the extension '.c', and would use .c the smart editing package for
 *      all three. Note also that since isn't specified as an extension,
 *      no packages are assigned to it. The following is required:
 *
 *          package: .asm:r;.cpp.hpp.h.c-c:smart
 *
 *      GRIEF shall first check for the package using the actual extension
 *      before for one with the equivalent extension. If in the previous
 *      example, 'smart' identing was available for .cpp files, GRIEF would
 *      use the .cpp support over the .c support.
 *
 *      This feature is useful when the extension is no automaticlly
 *      recongnised and is unable to provide 'smart' indenting. Using
 *      extension equivalence, inform GRIEF that an unsupported extension
 *      should be treated like an equivalent supported one.
 *
 *          package: .default:hilite;.c:hilite,t 1 1 0 1
 *
 *      The extension '.default' is used as a wild card (or default),
 *      to any match an extension not explicity listed. The above
 *      example enables the hilite package on implicity supported
 *      file types, plus an explicit configuration for the '.c'
 *      extension.
 *
 *  package
 *      Is the macro package attached to the extension. Each extension can
 *      have multiple packages associated with it, as long as the package
 *      don't conflict.
 */

#include "grief.h"
#include "mode.h"

//  #define LOCALPACKAGES
#if (0)
#define DEBUG(_x)   dprintf _x;
#else
#define DEBUG(_x)
#endif

#if defined(__PROTOTYPES__)
void                _pkg_calls_on(void);
void                _pkg_calls_first(void);
static string       _pkg_lookup(string event_name, string mode,
                            string equiv_ext, string mac_name, int processed);
static void         _pkg_reset(void);
static string       _pkg_abbrev(void);
#endif

int                 _package_buf;
string              _curr_active = "";


/*
 *  main ----
 *      Register edit & open new hooks.
 */
void
main(void)
{
    register_macro(REG_NEW, "_pkg_calls_first");
    register_macro(REG_EDIT, "_pkg_calls_on");
    _package_buf = create_buffer("Packages", NULL, TRUE);
}


/*
 *  _package_dump ---
 *      Diagnostics interface.
 */
void
_package_dump(void)
{
    int cur_buf = inq_buffer();

    set_buffer(_package_buf);
    top_of_buffer();
    drop_anchor(MK_LINE);
    end_of_buffer();
    copy();
    raise_anchor();
    set_buffer(cur_buf);
    paste();
}


/*
 *  _pkg_calls_on ---
 *      Call "on" event.
 */
void
_pkg_calls_on(void)
{
    _package_call("_on", "");
}


/*
 *  _pkg_calls_first ---
 *    Call new if file is new and first for either case.
 */
void
_pkg_calls_first(void)
{
    string pathname;

    inq_names(pathname);
    if (!exist(pathname)) {
        _package_call("_new", "");
    }
    _package_call("_first", "");
}


/*
 *  _package_call ---
 *    This macro is the main event parser and dispatcher for the language
 *    package system. It calls packages specified in the BPACKAGES
 *    environment variable in response to events generated by the system or
 *    by the user. It then maintains some housekeeping information that
 *    allows rapid access to these pacakages in the future.
 *
 */
void
_package_call(string event_name, string mode)
{
    string to_call, mac_name, curr_ext, escaped_ext, equiv_ext, bpackages, curr_bpackage;
    int loc, end, file_buf, already_parsed;

    if (inq_system() ||                         /* ignore system */
            (inq_buffer_flags() & BF_BINARY))   /* and binary buffer */
        return;

    /*  First, we get the event type and the extension of the file If there are
     *  any "off" macro to call (saved in the _curr_active global string), we
     *  reset them before continuing.
     */
    if (strlen(mode) == 0) {
        mode = _mode_pkg_get();
    } else {
        _mode_pkg_set(mode);
    }

    curr_ext = mode;
    escaped_ext = quote_regexp(curr_ext);
    DEBUG(("pkg(%s,%s)", event_name, mode))
    if (strlen(escaped_ext) == 0) {             /* no extension available */
        DEBUG(("pkg: no extension"))
        return;
    }

    _pkg_reset();

    /*
     *  The global _package_buf contains housekeeping information that allows the language system
     *  to keep parsed event information around for the duration of the editing session. Each
     *  event occupies one line in the buffer (per extension), and one additional line is taken
     *  per extension to save the pre-parsed packages and arguments.
     *
     *  Extensions are always found together in the package buffer; the events come first,
     *  followed by the pre-parsed information. This allows the search pattern to fall through to
     *  the pre-parsed information if the event hasn't occurred yet.
     *
     *  The format of the strings is:
     *
     *      [extension][event name, or nothing if pre_parse];[information]
     *
     */
#if !defined(DEBUG)
    int ml = set_msg_level(1);
#endif
    file_buf = inq_buffer();
    set_buffer(_package_buf);
    top_of_buffer();

    already_parsed = search_fwd("<_" + escaped_ext + "\\c{" + event_name + "}@;");
    if (already_parsed) {
        next_char(--already_parsed);
        to_call = rtrim(read());

    } else {
        int located, pass;
        string pattern;

        /*
         *  If no information is present in the buffer for the given extension, the BPACKAGES
         *  string must be retrieved from the environment and parsed. Note that this will only
         *  happen once per extension. Since the BPACKAGES string is quite complex, and a given
         *  extension can appear more than once (and with a number of different packages), and
         *  parser loops and search for the extension until it can't be located any more.
         *
         *  If the extension isn't found at all, the "default" extension is used and a second
         *  pass is made over the BPACKAGES string. If neither the extension nor the "default"
         *  extension is found, no events are generated for this extension.
         *
         */
        top_of_buffer();

#if defined(LOCALPACKAGES)
        bpackages = ".cc.CC.cpp.hpp.c.cr.h-c:hilite" + ";.c:t 0 0 0 0;.default:hilite";
#else
        bpackages = compress(gri_package);      /* global package setting */
#endif
        if (0 == strlen(bpackages)) {
            bpackages = ".default:hilite";
        }

        DEBUG(("pkg: %s", bpackages))
        bpackages = bpackages + ";";            /* terminate image */

        to_call = "";
        located = 0;
        curr_ext = mode;                        /* search for match */

        for (pass = 1; pass <= 2; pass++) {     /* curr_ext and "default" passes */
            escaped_ext = quote_regexp(curr_ext);
            DEBUG(("pkg: PASS(%d) x(%s) d(%s)", pass, escaped_ext, bpackages))

                                                /* retrieve next specification */
            pattern = ".\\c" + escaped_ext + "{[.:\\-][~;]@";

            while ((loc = re_search( SF_IGNORE_CASE, pattern, bpackages )) > 0) {
                ++located;

                /* Retrieved definition:
                 *
                 *      extension[,extension][-equiv]:package[,package][;]
                 */
                bpackages = substr(bpackages, loc);

                if ((end = index(bpackages, ";"))) {
                    end -= 1;
                } else {
                    end = strlen(bpackages);
                }
                curr_bpackage = substr(bpackages, 1, end);
                bpackages = substr(bpackages, end + 1);
                DEBUG(("pkg: found(%s)", curr_bpackage))

                /* Check for an equivalent (file extension override) */
                equiv_ext = "";
                if ((loc = index(curr_bpackage, "-")) == 0) {
                    equiv_ext = "";             /* no equiv specification */

                } else {                        /* cut */
                    equiv_ext = substr(curr_bpackage, loc+1, index(curr_bpackage, ":") - (loc+1));
                    curr_bpackage = substr(curr_bpackage, loc);
                }

                /* All of the pre-expansion packages for the current extension are combined
                 * together in the to_call string separated by commas.
                 *
                 * This string is used later to expand and call the individual package macros,
                 * and is inserted into the buffer as pre-parsed information once the parse
                 * has been completed.
                 */
                if (strlen(to_call)) {
                    to_call += ",";             /* append to existing */
                }
                to_call += "-" + equiv_ext + ":";
                to_call += substr(curr_bpackage, index(curr_bpackage, ":")+1);
            }

            /* If we can't find the extension any more and we've located
             * some packages to call, then the parse is over. Otherwise,
             * we use "default" as the extension and try one more time
             */
            if (located) {                      /* package match */
                break;
            }
            curr_ext = "default";               /* second pass */
        }
    }

    /* If the package buffer didn't contain any information about the current
     * file extension, we insert the pre-parse information at the top of the
     * buffer. This information can be used later to avoid doing an additional
     * BPACKAGES parse.
     */
    beginning_of_line();
    if (!already_parsed) {
        /* We move up here because the event information must appear before the
         * pre-parse information, and the "\n" that was inserted moves us down a
         * line.
         */
        insert("_" + mode + ";" + to_call + "\n");
        up();
    } else {
        /* As you may recall, locating the pre-parse information will set
         * already_parsed to 2, and locating specific event information will set
         * it to some number above that (depending on the length of the event
         * name). Decrementing already_parsed at this point will force the
         * insertion of event-specific information if only pre-parsed
         * information had been located in the package buffer search.
         */
        --already_parsed;
    }

    /* At this point, we've got a list of pre-expanded package names that look
     * something like "s,pvcs,wp". These have to be expanded and converted
     * into the event and extension specific variety. Each individual package
     * is separated and passed to process_package, which expands the name (if
     * necessary), handles extension-specific and generic naming conventions,
     * deals with parameters, and the like. Once completed, the expanded
     * package name (if any) is returned and saved in another string that will
     * be inserted as the event-specific information in the package buffer.
     */
    set_buffer(file_buf);
    bpackages = "";
    equiv_ext = "";

    DEBUG(("pkg:  to_call(%s)", to_call))
    while (strlen(to_call)) {                   /* for each to call entry */

        if ((end = index(to_call, ",")) == 0)   /* next package */
            end = strlen(to_call) + 1;

        if (index(to_call, "-") == 1 &&         /* prefixed extension specification */
                (loc = index(to_call, ":")) && loc < end) {
            equiv_ext = substr(to_call, 2, loc - 2);
            to_call = substr(to_call, loc + 1);
            if ((end = index(to_call, ",")) == 0) {
                end = strlen(to_call) + 1;
            }
        }
                                                /* expand the package */
        mac_name = _pkg_lookup(event_name, mode, equiv_ext,
                        trim(substr(to_call, 1, end-1)), already_parsed);

        DEBUG(("pkg:  process(%s,%s,%s) : %s", mode, equiv_ext, trim(substr(to_call, 1, end-1)), mac_name))
        if (strlen(mac_name)) {                 /* package located */
            if (strlen(bpackages)) {            /* append to resulting package list */
                bpackages += ",";
            }
            bpackages += mac_name;
        }
        to_call = substr(to_call, end + 1);     /* remove package */
    }

    DEBUG(("pkg:  result(%s:%s,%s)", mode, event_name, bpackages))

    /* If the event-specific information wasn't found in the
     * buffer, it's inserted here.
     */
    if (! already_parsed) {
        file_buf = inq_buffer();
        set_buffer(_package_buf);
        insert("_" + mode + event_name + ";" + bpackages + "\n");
        set_buffer(file_buf);
    }

#if !defined(DEBUG)
    set_msg_level(ml);
#endif
}


/*
 *  _pkg_lookup ---
 *    This macro converts generic package names into their generic or
 *    extension-specific macro name counterparts.
 */
static string
_pkg_lookup( string event_name, string mode,
        string equiv_ext, string mac_name, int processed)
{
    /* If the names haven't already been parsed and expanded by
     * this routine, we have a lot of work to do. This work is
     * skipped once it has been done once.
     */
    if (! processed) {
        string initial_mac, attr, parms;
        int loc, length;

        loc = index(mac_name, " ");
        if (loc) {
            parms = substr(mac_name, loc + 1);
            mac_name = substr(mac_name, 1, loc - 1);
        } else {
            parms = "";
        }

        /*  If part of the package name is found in the abbreviation
         *  list, the full name is retrieved and used instead.
         *
         *  Note that the macros in the abbreviation list could be
         *  demotable groups (separated by commas).
         */
        if (mac_name == "hilite" || mac_name == "hilight") {
            mac_name = "highlight";             /* alias */
        }
        initial_mac = _pkg_abbrev();
        loc = re_search(NULL, "[,;]" + mac_name + "[~;]+;", initial_mac, NULL, length);
        initial_mac =
            (loc > 0) ? substr(initial_mac, loc + 1, length - 2) : mac_name;


        /*  This loop searches for specific and generic event handler macros.
         *
         *  First, specific macros are searched for.
         *
         *       o mode
         *       o equivlent
         *       o thru modes module
         *
         *  If none are found, the last member of the demotable group is searched for
         *  generically.  This is because generic higher level demotion macros don't
         *  make any sense (they'd override anything else, and wouldn't leave anything
         *  to demote to).
         */
        while (! processed) {
            /*
             *  build function name
             */
            loc = index(initial_mac, ",");      /* template,smart,regular */
            if (! loc) {
                loc = strlen(initial_mac) + 1;
            }
            attr = substr(initial_mac, 1, loc-1);
            initial_mac = substr(initial_mac, loc + 1);
            mac_name = "_" + attr + event_name; /* _template_first */

            /*
             *  search for a matching handler
             *
             *      a) extension        (eg. _cr_template_first)
             *      b) alias            (eg. _c_template_first)
             *      c) module lookup/map
             */
            if ((processed = inq_macro("_" + mode + mac_name, 1)) > 0) {
                mac_name = "_" + mode + mac_name;

            } else if (strlen(equiv_ext) &&
                    (processed = inq_macro("_" + equiv_ext + mac_name, 1)) > 0) {
                mac_name = "_" + equiv_ext + mac_name;

            } else {                            /* ask modes module (if loaded) */
                string ret;

                if (inq_macro("_mode_package", 1) > 0 &&
                        (ret = _mode_package(mode, mac_name)) != "") {
                    mac_name = ret;
                    processed = 1;

                } else if (strlen(initial_mac) == 0) {
                                                /* demote to _template_first (see ident) */
                    processed = inq_macro(mac_name, 1);
                    break;
                }
            }
        }

        if (processed) {
            if (strlen(parms)) {
                mac_name += " " + parms;
            }
        }
    }

    /*
     *  If the macro has been processed & located, we call it with its parameters.
     */
    if (processed) {
        string attr;

        DEBUG(("pkg:  processing(%s)", mac_name))
        if (event_name == "_first") {           /* assign attributes */
            int loc;

            loc = index(mac_name, " ");
            attr = substr(mac_name, 1, rindex( mac_name, "_" ) - 1);
            attr = substr(attr, rindex( attr, "_" ) + 1);
            if (loc) {
                _mode_attr_set(attr, substr( mac_name, loc+1 ));
            } else {
                _mode_attr_set(attr, "");
            }
        }

        attr = execute_macro(mac_name);         /* exec, returns '_off' action */

        if (attr != "" && event_name == "_on") {
            if (strlen(_curr_active)) {
                _curr_active += ";";
            }
            _curr_active += attr;
        }
        return mac_name;                        /* matched function */
    }
    return "";                                  /* not found */
}


/*
 *  _pkg_reset ---
 *      This macro processes the "off" event. Any macros that returned off
 *      event macros from their event handlers have those strings kept in the
 *      _curr_active global variable. These macros are called here. Note that
 *      "off" macro strings should never contain semicolons.
 */
static void
_pkg_reset(void)
{
    int loc;

    while (strlen(_curr_active)) {
        loc = index(_curr_active, ";");
        if (!loc) {
            loc = strlen(_curr_active) + 1;
        }
        execute_macro(substr(_curr_active, 1, loc - 1));
        _curr_active = substr(_curr_active, loc + 1);
    }
}


/*
 *  _pkg_abbrev ---
 *      This macro is at the terminus of the chain. It returns a string
 *      consisting of the abbreviations and demotable groups for the built-in
 *      packages (hilite,indenting, word processing and pvcs).
 */
static string
_pkg_abbrev(void)
{
    return "highlight;template,smart,regular;smart,regular;pvcs;wp;";
}

/*
 *  Local Variables: ***
 *  mode: cr ***
 *  indent-width: 4 ***
 *  End: ***
 */





